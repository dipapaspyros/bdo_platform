# -*- coding: utf-8 -*-
# Generated by Django 1.9 on 2017-06-21 10:21
from __future__ import unicode_literals

from datetime import datetime
import time

from django.db import migrations
from django.db.utils import ProgrammingError
from aggregator.models import Dimension
from django.db import connections


def forwards(_, __):
    min_dimension_map = {}
    max_dimension_map = {}
    for d in Dimension.objects.all():
        if d.variable.dataset.stored_at == 'UBITECH_POSTGRES':
            min_dimension_map, max_dimension_map = update_min_max_dimension_values(d, min_dimension_map,
                                                                                   max_dimension_map)


def update_min_max_dimension_values(dimension, min_dimension_map,
                                    max_dimension_map):
    cursor, dim_dataset_name, dim_name = init_variables(dimension)

    if (dim_name, dim_dataset_name) not in min_dimension_map:
        min_max_dimension_query = build_query_string(dim_dataset_name, dim_name)
        try:
            cursor.execute(min_max_dimension_query)
        except ProgrammingError as e:
            print "query execution failed due to: ", e
            return min_dimension_map, max_dimension_map

        max_dim, min_dim, res = get_query_results(cursor)

        if isinstance(res[0], datetime):
            try:
                max_dim, min_dim = translate_time_dims_to_timestamps(res)
            except OverflowError as e:
                print "invalid date ", res[0], " or ", res[1], " due  to: ", e
                return min_dimension_map, max_dimension_map

        min_dimension_map[dim_name, dim_dataset_name] = min_dim
        max_dimension_map[dim_name, dim_dataset_name] = max_dim

    update_dimension(dimension, max_dimension_map[dim_name, dim_dataset_name],
                     min_dimension_map[dim_name, dim_dataset_name])
    return min_dimension_map, max_dimension_map


def update_dimension(dimension, max_dimension, min_dimension):
    update_dimension_min_if_needed(min_dimension, dimension)
    update_dimension_max_if_needed(max_dimension, dimension)
    dimension.save()


def get_query_results(cursor):
    res = cursor.fetchone()
    min_dim = res[0]
    max_dim = res[1]
    return max_dim, min_dim, res


def translate_time_dims_to_timestamps(res):
    min_dim = time.mktime(res[0].timetuple())
    max_dim = time.mktime(res[1].timetuple())
    if min_dim > max_dim:
        min_dim = 0

    return max_dim, min_dim


def update_dimension_max_if_needed(max_dimension, dimension):
    if max_dimension is not None:
        dimension.max = max_dimension


def update_dimension_min_if_needed(min_dimension, dimension):
    if min_dimension is not None:
        dimension.min = min_dimension


def build_query_string(dim_dataset_name, dim_name):
    min_max_dimension_query = """
                SELECT
                    MIN(%s),
                    MAX(%s)
                FROM %s
            """ % (dim_name, dim_name, dim_dataset_name)
    return min_max_dimension_query


def init_variables(dimension):
    cursor = connections['UBITECH_POSTGRES'].cursor()
    dim_name = dimension.name
    dim_dataset_name = dimension.variable.data_table_name
    return cursor, dim_dataset_name, dim_name


class Migration(migrations.Migration):
    dependencies = [
        ('aggregator', '0013_auto_20180506_2318'),
    ]

    operations = [
        migrations.RunPython(forwards)
    ]
